\chapter{実行結果}
\section{実行結果}
\subsection{実装環境}
\noindent プロセッサ: Intel(R) Xeon(TM) CPU 3.40GHz\\
メモリ: 2046MB RAM\\
OS: Microsoft Windows XP Professional\\
プログラミング言語: Magma ver.2.14-6

\subsection{実装条件}
\noindent
部分群の位数$n$はランダムに選ぶ. \\
計測は演算部分だけに対して1000回行い, その平均を取った. \\
楕円曲線は埋め込み次数$k=2,\ 4,\ 6$でordinary curveを使用した. \\
実験で使用した曲線は以下の通り. $k=4$の曲線は\cite{OPM}, $k=6$の曲線は\cite{GMM}の例題から引用した. 
\begin{enumerate}
\item $k=2のとき,\ y^2=x^3+x$\\
\item $k=4のときy^2 = x^3 - 3x + b,\ b=2993400528565252484131025435851646783754072514402$\\
\item $k=6のときy^2 = x^3 - 3x + b,\ b=1067782606939229981648974648369145174879546988730$\\
\end{enumerate}
\clearpage
\subsection{実行結果}
$\mbox{log}n \approx 80,120,160$のときの従来手法と提案手法の計算コストと計算時間を次の表に示す. \\
%\vspace{7mm}
\begin{table}[htb]
 \begin{center}
  \begin{tabular}{|l|c|c|}
  \hline
  82bit($b_{max} = 50,\ t_{max} = 20,\ m = 13$) & 計算コスト& 計算時間\\
  \hline
  Miller Algorithm & 3329 & 12.9ms \\
  \hline
  Signed Miller Algorithm & 2906 & 11.3ms \\
  \hline
  Double-Base Chainsを用いたMiller Algorithm & 2487 & 9.6ms \\
  \hline
  \end{tabular}
 \end{center}
 \caption{$k=2,\ \mbox{log}n \approx 80$}
\end{table}
\begin{table}[htb]
 \begin{center}
  \begin{tabular}{|l|c|c|}
  \hline
  120bit($b_{max} = 68,\ t_{max} = 33,\ m = 13$) & 計算コスト& 計算時間\\
  \hline
  Miller Algorithm & 4885 & 21.1ms \\
  \hline
  Signed Miller Algorithm & 4242 & 18.6ms \\
  \hline
  Double-Base Chainsを用いたMiller Algorithm & 3483 & 15.5ms \\
  \hline
  \end{tabular}
 \end{center}
 \caption{$k=2,\ \mbox{log}n \approx 120$}
\end{table}
\begin{table}[htb]
 \begin{center}
  \begin{tabular}{|l|c|c|}
  \hline
  159bit($b_{max} = 97,\ t_{max} = 39,\ m = 17$) & 計算コスト& 計算時間\\
  \hline
  Miller Algorithm & 6481 & 32.9ms \\
  \hline
  Signed Miller Algorithm & 5614 & 29.2ms \\
  \hline
  Double-Base Chainsを用いたMiller Algorithm & 4565 & 25.1ms \\
  \hline
  \end{tabular}
 \end{center}
 \caption{$k=2,\ \mbox{log}n \approx 160$}
\end{table}
\begin{table}[htb]
 \begin{center}
  \begin{tabular}{|l|c|c|}
  \hline
  161bit($b_{max} = 72,\ t_{max} = 56,\ m = 24$) & 計算コスト& 計算時間\\
  \hline
  Miller Algorithm & 6563 & 43.8ms \\
  \hline
  Signed Miller Algorithm & 5684 & 42.5ms \\
  \hline
  Double-Base Chainsを用いたMiller Algorithm & 4697 & 34.9ms \\
  \hline
  \end{tabular}
 \end{center}
 \caption{$k=2,\ \mbox{log}n \approx 160$}
\end{table}
\begin{table}[htb]
 \begin{center}
  \begin{tabular}{|l|c|c|}
  \hline
  162bit($b_{max} = 113,\ t_{max} = 31,\ m = 45$) & 計算コスト& 計算時間\\
  \hline
  Miller Algorithm & 12623 & 66.2ms \\
  \hline
  Signed Miller Algorithm & 9273 & 64.0ms \\
  \hline
  Double-Base Chainsを用いたMiller Algorithm & 8796 & 59.0ms \\
  \hline
  \end{tabular}
 \end{center}
 \caption{$k=4,\ \mbox{log}n \approx 160$}
\end{table}
\begin{table}[htbp]
 \begin{center}
  \begin{tabular}{|l|c|c|}
  \hline
  159bit($b_{max} = 80,\ t_{max} = 49,\ m = 36$) & 計算コスト& 計算時間\\
  \hline
  Miller Algorithm & 19795 & 78.4ms \\
  \hline
  Signed Miller Algorithm & 13289 & 77.8ms \\
  \hline
  Double-Base Chainsを用いたMiller Algorithm & 12205 & 64.8ms \\
  \hline
  \end{tabular}
 \end{center}
 \caption{$k=6,\ \mbox{log}n \approx 160$}
\end{table}
\vspace{2cm}
\par
提案手法は従来手法に比べて表7.1から82bitでは34\%, 18\%, 表7.2から120bitでは36\%, 20\%, 表7.3から159bitでは31\%, 16\%, 表7.4から161bitでは25\%, 22\%の高速化を実現した. 
さらに既存研究を実装した結果、表7.5から$k=4$で160bitのとき,  12\%, 8\%, 表7.6から$k=6$で160bitのとき, 21\%, 20\%の高速化を実現した. 
\clearpage
\chapter{考察と今後の課題}
\section{考察}
実行結果の表を二つに分類して考察する.\\

\noindent (1) 表7.1, 7.2, 7.3について考える. \\
\par
計算コストからMiller Algorithm, Signed Miller Algorithmに比べて表7.1から82bitでは34\%, 17\%, 表7.2から120bitでは40\%, 22\%, 表7.3から159bitでは42\%, 23\%の高速化が予想できるが, 実際に計算時間を比較すると計算コストに比べて多少遅かった. これはDouble-Base Chainsを用いる場合, TDBL, TTRLを行うが, 第6章で表にしたようにTTRLのほうが計算コストが高い. 具体的に示すとTTRL $\approx$ 1.32TDBLとなる. したがって, $t_{max}$の値は少なくとも$b_{max} > 1.3t_{max}$であることが望ましいと思われる. 加えて各ステップで$t_m$の値が減らない場合, 計算が2倍算に比べて遅い3倍算が残ってしまうので, $t_m$より先に$b_m$が0になる場合, 計算コストと比較するとき, 計算時間が遅くなると予想される. 2倍算に関しても遅くなると予想される. Miller Algorithmはleft-to-right法で2進展開を行っているが, Double-Base Chainsを用いる場合ではそれができないので$t_m$が0になるときも, $b_m$がある程度少なくなることが望ましいと思われる. \\

\bigskip

\noindent (2) 表7.4, 7.5, 7.6について考える. \\
\par
計算コストから表7.4から$k=2$のとき, 40\%, 21\%, 表7.5から$k=4$のとき, 43\%, 5\%, 表7.6から$k=6$のとき, 62\%, 9\%の高速化を予想しているが, Miller Algorithmで計算時間を比較すると計算コストを下回り, Sigend Miller Algorithmでは計算コストを上回った. 主な原因としては前述の(1)が考えられる. 加えてDouble-Base Chainsを用いたMiller Algorithm全体のループ回数とループ部分の演算の複雑性が原因だと思われる. \cite{DBNS}では$n$の値をDouble-Base Chainに適した最適な値を選ぶと仮定している. \cite{DBCT}では計算コストを求めるとき, \cite{DBNS}の結果を参照し, Miller Algorithmと同様に, 計算コストでもループ回数$m$が考慮されている. しかし, ループ部分の計算の複雑性から全体のループ回数と合わせるとどれだけ負担になるかについて言及していないので, $m$の値が大きいと従来手法と比較するとき, ループ部分の演算の複雑性により, 計算コストと計算時間にかなりの差が出てしまうことが予想される. 加えて(1)でも述べたが, Double-Base Chainはleft-to-right法が出来ないので、計算速度が遅くなった. 実際$k=4,\ 6$のときのHamming Weightは計算コストとほぼ同じであったことから, このことが原因であることが推定される. 
\par
Signed Miller Algorithmについて$k=6$で高速化が可能になったのは, 符号付き2進展開をした場合, ループ回数があまり減らなかったためである. 計算コストでは\{-1,1\}の数は$n/3$個としているが, それ以上の個数が出てしまったため, 計算時間に差が生じた. 
\section{今後の課題}
考察から, 計算速度をさらに速くするためには各ステップの$b_m,\ t_m(特にt_m)$の値の減少の度合いを少なくすることとループ回数$m$を小さくすることが言える. 現在, Double-Base Chainsの高速化手法として木構造を用いた手法が提案されている. この手法は楕円曲線$E(\mathbb{F}_q)$上の点の加算で使われていて, $m$をより小さくすることが可能である. したがって, この手法を適用すれば, さらにDouble-Base Chainsを用いたMiller Algorithmを高速化することが可能である. 
\par
\cite{DBNS}でも述べられているが, Double-Base Chainsに最適な値という定義が明確ではないので, これを明確にすることで高速化することが可能である. 加えてそのような曲線がどれだけ存在するのか調べる必要がある. 
\par
今回はordinary curveに対してMiller AlgorithmにDouble-Base Chainsを用いたが, BKLS Algorithmに拡張することやペアリングの手法であるAte ペアリングへの適用することも可能である. 